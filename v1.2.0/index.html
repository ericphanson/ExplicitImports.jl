<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ExplicitImports.jl</title><meta name="title" content="Home · ExplicitImports.jl"/><meta property="og:title" content="Home · ExplicitImports.jl"/><meta property="twitter:title" content="Home · ExplicitImports.jl"/><meta name="description" content="Documentation for ExplicitImports.jl."/><meta property="og:description" content="Documentation for ExplicitImports.jl."/><meta property="twitter:description" content="Documentation for ExplicitImports.jl."/><meta property="og:url" content="https://ericphanson.github.io/ExplicitImports.jl/"/><meta property="twitter:url" content="https://ericphanson.github.io/ExplicitImports.jl/"/><link rel="canonical" href="https://ericphanson.github.io/ExplicitImports.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ExplicitImports.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Documentation-Index"><span>Documentation Index</span></a></li></ul></li><li><a class="tocitem" href="api/">API reference</a></li><li><a class="tocitem" href="internals/">Dev docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ericphanson/ExplicitImports.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ericphanson/ExplicitImports.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1>ExplicitImports</h1><p><a href="https://github.com/ericphanson/ExplicitImports.jl/actions/workflows/CI.yml?query=branch%3Amain"><img src="https://github.com/ericphanson/ExplicitImports.jl/actions/workflows/CI.yml/badge.svg?branch=main" alt="Build Status"/></a> <a href="https://codecov.io/gh/ericphanson/ExplicitImports.jl"><img src="https://codecov.io/gh/ericphanson/ExplicitImports.jl/branch/main/graph/badge.svg" alt="Coverage"/></a></p><h2>Goal</h2><p>Figure out what implicit imports a Julia module is relying on, in order to make them explicit.</p><h2>Terminology</h2><ul><li><em>implicit import</em>: a name <code>x</code> available in a module due to <code>using XYZ</code> for some package or module <code>XYZ</code>. This name has not been explicitly imported; rather, it is simply available since it is exported by <code>XYZ</code>.</li><li><em>explicit import</em>: a name <code>x</code> available in a module due to <code>using XYZ: x</code> or <code>import XYZ: x</code> for some package or module <code>XYZ</code>.</li></ul><h2>Why</h2><p>Relying on implicit imports can be problematic, as Base or another package can start exporting that name as well, resulting in a clash. This is a tricky situation because adding a new feature to Base (or a package) and exporting it is not considered a breaking change to its API, but it can cause working code to stop working due to these clashes.</p><p>If you&#39;ve even seen a warning like:</p><blockquote><p>WARNING: both X and Y export &quot;foo&quot;; uses of it in module MyPackage must be qualified</p></blockquote><p>Then this is the kind of clash at issue. When this occurs, the name <code>foo</code> won&#39;t point to either package&#39;s name, since it is ambiguous which one it should be. However, if the package code is relying on the name <code>foo</code> existing, then there&#39;s trouble.</p><p>One fix, as the warning suggests, is to qualify the use <code>foo</code> by writing e.g. <code>X.foo</code> or <code>Y.foo</code>. Another option is to explicitly import it, by writing <code>using X: foo</code> instead of just <code>using X</code>.</p><p>There are various takes on <em>how problematic</em> this issue is, to what extent this occurs in practice, and to what extent it is worth mitigating. See <a href="https://github.com/JuliaLang/julia/pull/42080">julia#42080</a> for some discussion on this.</p><p>Personally, I don&#39;t think this is always a huge issue, and that it&#39;s basically fine for packages to use implicit imports if that is their preferred style and they understand the risk. But I do think this issue is somewhat a &quot;hole&quot; in the semver system as it applies to Julia packages, and I wanted to create some tooling to make it easier to mitigate the issue for package authors who would prefer to not rely on implicit imports.</p><h2>Implementation status</h2><p>This seems to be working! However it has not been extensively used or tested.</p><p>See the <a href="https://ericphanson.github.io/ExplicitImports.jl/dev/api/">API docs</a> for the available functionality.</p><h2>Example</h2><pre><code class="language-julia hljs">julia&gt; using ExplicitImports

julia&gt; print_explicit_imports(ExplicitImports)
WARNING: both JuliaSyntax and Base export &quot;parse&quot;; uses of it in module ExplicitImports must be qualified
Module ExplicitImports is relying on implicit imports for 6 names. These could be explicitly imported as follows:

```julia
using AbstractTrees: AbstractTrees
using AbstractTrees: Leaves
using AbstractTrees: TreeCursor
using AbstractTrees: children
using AbstractTrees: nodevalue
using JuliaSyntax: JuliaSyntax
```
</code></pre><p>Note: the <code>WARNING</code> is more or less harmless; the way this package is written, it will happen any time there is a clash, even if that clash is not realized in your code. I cannot figure out how to suppress it.</p><p>You can also pass <code>show_locations=true</code> for more details:</p><pre><code class="language-julia hljs">julia&gt; print_explicit_imports(ExplicitImports; show_locations=true)
Module ExplicitImports is relying on implicit imports for 6 names. These could be explicitly imported as follows:

```julia
using AbstractTrees: AbstractTrees # used at /Users/eph/ExplicitImports/src/parse_utilities.jl:51:10
using AbstractTrees: Leaves # used at /Users/eph/ExplicitImports/src/get_names_used.jl:225:17
using AbstractTrees: TreeCursor # used at /Users/eph/ExplicitImports/src/parse_utilities.jl:107:18
using AbstractTrees: children # used at /Users/eph/ExplicitImports/src/get_names_used.jl:161:26
using AbstractTrees: nodevalue # used at /Users/eph/ExplicitImports/src/parse_utilities.jl:96:34
using JuliaSyntax: JuliaSyntax # used at /Users/eph/ExplicitImports/src/parse_utilities.jl:103:15
```</code></pre><p>Note the paths of course will differ depending on the location of the code on your system.</p><p>This can be handy for debugging; if you find that in fact ExplicitImports thinks a local variable is a global from another module, please file an issue and include the code snippet!</p><h2>Limitations</h2><h3>Some tricky scoping situations are not handled correctly</h3><p>These can likely all be fixed by improving the code in <code>src/get_names_used.jl</code>, so they aren&#39;t inherent limitations of this approach, but since we are re-implementing Julia&#39;s scoping rules on top of the parse tree, for fully accurate results we need to handle each situation correctly, which takes a lot of work.</p><p>Known issues:</p><ul><li><code>global</code> and <code>local</code> keywords are currently ignored</li><li>multi-argument <code>include</code> calls are ignored</li><li>In Julia, <code>include</code> adds the included code at top-level in the module in which it is called. Here, when <code>include</code> is called within a local scope, all of the code being included is treated as being within that local scope.</li><li>quoted code (e.g. when building Julia expressions programmatically) may be analyzed incorrectly</li></ul><p>The consequence of these issues is that ExplicitImports may misunderstand whether or not a particular name refers to a local variable or a global one, and thus whether or not some particular implicitly-available name (exported by some module) is in fact being used. This could cause it to suggest an unnecessary explicit import, fail to suggest an explicit import, or to falsely claim that an explicit import is stale.</p><p>Hopefully these situations are somewhat rare, because even if ExplicitExports misunderstands the scoping for one usage of a name, it may correctly parse the scoping of it in another usage in the same module, and could end up drawing the correct conclusion anyway.</p><p>Additionally, the testing-oriented functions <code>check_no_implicit_imports</code> and <code>check_no_stale_explicit_imports</code> have the ability to filter out problematic names or modules, to allow manual intervention in cases in which ExplicitImports gets it wrong.</p><h3>Cannot recurse through dynamic <code>include</code> statements</h3><p>These are <code>include</code> in which the argument is not a string literal. For example, the package MathOptInterface.jl currently includes the following code in it&#39;s <code>Test</code> module:</p><pre><code class="language-julia hljs">for file in readdir(@__DIR__)
    if startswith(file, &quot;test_&quot;) &amp;&amp; endswith(file, &quot;.jl&quot;)
        include(file)
    end
end</code></pre><p>This is problematic for ExplicitImports.jl; unless we really use a full-blown interpreter (which I do think could be a viable strategy<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>), we can&#39;t really execute this code to know what files are being included. Thus being unable to traverse dynamic includes is essentially an inherent limitation of the approach used in this package.</p><p>The consequence of missing files is that the any names used or imports made in those files are totally missed. Even if we did take a strategy like &quot;scan the package <code>src</code> directory for Julia code, and analyze all those files&quot;, without understanding <code>includes</code>, we wouldn&#39;t understand which files belong to which modules, making this analysis useless.</p><p>However, we do at least detect this situation, so we can know which modules are affected by the missing information, and (by default) refuse to make claims about them. For example, running <code>print_explicit_imports</code> on this module gives:</p><pre><code class="language-sh hljs">julia&gt; print_explicit_imports(MathOptInterface.Test, pkgdir(MathOptInterface))
Module MathOptInterface.Test could not be accurately analyzed, likely due to dynamic `include` statements. You can pass `strict=false` to attempt to get (possibly inaccurate) results anyway.

Module MathOptInterface.Test._BaseTest could not be accurately analyzed, likely due to dynamic `include` statements. You can pass `strict=false` to attempt to get (possibly inaccurate) results anyway.</code></pre><p>Note here we need to pass <code>pkgdir(MathOptInterface)</code> as the second argument, as <code>pathof(MathOptInterface.Test) === nothing</code> and we would get a <code>FileNotFoundException</code>.</p><p>If we do pass <code>strict=false</code>, in this case we get</p><pre><code class="language-sh hljs">julia&gt; print_explicit_imports(MathOptInterface.Test, pkgdir(MathOptInterface); strict=false)
Module MathOptInterface.Test is not relying on any implicit imports.

Module MathOptInterface.Test._BaseTest is not relying on any implicit imports.</code></pre><p>However, we can&#39;t really be sure there is&#39;t a reliance on implicit imports present in the files that we weren&#39;t able to scan (or perhaps some stale explicit imports made in those files, or perhaps usages of names explicitly imported in the files we could scan, which would prove those explicit imports are in fact not stale).</p><h3>Need to load the package/module</h3><p>This implementation relies on <code>Base.which</code> to introspect which module any given name comes from, and therefore we need to load the module, not just inspect its source code. We can&#39;t solely use the source code because implicit imports are implicit – which is part of the criticism of them in the first place, that the source file alone does not tell you where the names come from.</p><p>In particular, this means it is hard to convert implicit imports to explicit as a formatting pass, for example.</p><p>Given a running <a href="https://github.com/julia-vscode/LanguageServer.jl">language server</a>, however, I think it should be possible to query that for the information needed.</p><h2 id="Documentation-Index"><a class="docs-heading-anchor" href="#Documentation-Index">Documentation Index</a><a id="Documentation-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-Index" title="Permalink"></a></h2><ul><li><a href="internals/#ExplicitImports.analyze_all_names"><code>ExplicitImports.analyze_all_names</code></a></li><li><a href="api/#ExplicitImports.check_no_implicit_imports"><code>ExplicitImports.check_no_implicit_imports</code></a></li><li><a href="api/#ExplicitImports.check_no_stale_explicit_imports"><code>ExplicitImports.check_no_stale_explicit_imports</code></a></li><li><a href="api/#ExplicitImports.explicit_imports"><code>ExplicitImports.explicit_imports</code></a></li><li><a href="api/#ExplicitImports.explicit_imports_nonrecursive"><code>ExplicitImports.explicit_imports_nonrecursive</code></a></li><li><a href="internals/#ExplicitImports.find_implicit_imports"><code>ExplicitImports.find_implicit_imports</code></a></li><li><a href="internals/#ExplicitImports.get_names_used"><code>ExplicitImports.get_names_used</code></a></li><li><a href="internals/#ExplicitImports.inspect_session"><code>ExplicitImports.inspect_session</code></a></li><li><a href="api/#ExplicitImports.print_explicit_imports"><code>ExplicitImports.print_explicit_imports</code></a></li><li><a href="api/#ExplicitImports.print_explicit_imports_script"><code>ExplicitImports.print_explicit_imports_script</code></a></li><li><a href="api/#ExplicitImports.print_stale_explicit_imports"><code>ExplicitImports.print_stale_explicit_imports</code></a></li><li><a href="api/#ExplicitImports.stale_explicit_imports"><code>ExplicitImports.stale_explicit_imports</code></a></li><li><a href="api/#ExplicitImports.stale_explicit_imports_nonrecursive"><code>ExplicitImports.stale_explicit_imports_nonrecursive</code></a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>An alternate implementation using an <code>AbstractInterpreter</code> (like JET does) might solve this issue (at the cost of increased complexity), and possibly get some handling of tricky scoping situations &quot;for free&quot;.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 3 March 2024 14:08">Sunday 3 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
