<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · ExplicitImports.jl</title><meta name="title" content="API reference · ExplicitImports.jl"/><meta property="og:title" content="API reference · ExplicitImports.jl"/><meta property="twitter:title" content="API reference · ExplicitImports.jl"/><meta name="description" content="Documentation for ExplicitImports.jl."/><meta property="og:description" content="Documentation for ExplicitImports.jl."/><meta property="twitter:description" content="Documentation for ExplicitImports.jl."/><meta property="og:url" content="https://ericphanson.github.io/ExplicitImports.jl/api/"/><meta property="twitter:url" content="https://ericphanson.github.io/ExplicitImports.jl/api/"/><link rel="canonical" href="https://ericphanson.github.io/ExplicitImports.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExplicitImports.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Detecting-implicit-imports-which-could-be-made-explicit"><span>Detecting implicit imports which could be made explicit</span></a></li><li><a class="tocitem" href="#Looking-just-for-stale-explicit-exports"><span>Looking just for stale explicit exports</span></a></li><li><a class="tocitem" href="#Checks-to-use-in-testing"><span>Checks to use in testing</span></a></li><li><a class="tocitem" href="#Usage-with-scripts-(such-as-runtests.jl)"><span>Usage with scripts (such as <code>runtests.jl</code>)</span></a></li><li><a class="tocitem" href="#Non-recursive-variants"><span>Non-recursive variants</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Dev docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ericphanson/ExplicitImports.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ericphanson/ExplicitImports.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The main entrypoint for interactive use is <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a>. ExplicitImports.jl API also includes several other functions to provide programmatic access to the information gathered by the package, as well as utilities to use in regression testing.</p><h2 id="Detecting-implicit-imports-which-could-be-made-explicit"><a class="docs-heading-anchor" href="#Detecting-implicit-imports-which-could-be-made-explicit">Detecting implicit imports which could be made explicit</a><a id="Detecting-implicit-imports-which-could-be-made-explicit-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-implicit-imports-which-could-be-made-explicit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.print_explicit_imports" href="#ExplicitImports.print_explicit_imports"><code>ExplicitImports.print_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_explicit_imports([io::IO=stdout,] mod::Module, file=pathof(mod); skip=(mod, Base, Core), warn_stale=true, strict=true)</code></pre><p>Runs <a href="#ExplicitImports.explicit_imports"><code>explicit_imports</code></a> and prints the results, along with those of <a href="#ExplicitImports.stale_explicit_imports"><code>stale_explicit_imports</code></a>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>warn_stale=true</code>: if set, this function will also print information about stale explicit imports.</p></li><li><p><code>strict=true</code>: when <code>strict</code> is set, a module will be noted as unanalyzable in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li><li><p><code>show_locations=false</code>: whether or not to print locations of where the names are being used (and, if <code>warn_stale=true</code>, where the stale explicit imports are).</p></li></ul><p>See also <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a> and <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L114-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.explicit_imports" href="#ExplicitImports.explicit_imports"><code>ExplicitImports.explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">explicit_imports(mod::Module, file=pathof(mod); skip=(mod, Base, Core), warn_stale=true, strict=true)</code></pre><p>Returns a nested structure providing information about explicit import statements one could make for each submodule of <code>mod</code>. This information is structured as a collection of pairs, where the keys are the submodules of <code>mod</code> (including <code>mod</code> itself), and the values are <code>NamedTuple</code>s, with at least the keys <code>name</code>, <code>source</code>, and <code>location</code>, showing which names are being used implicitly, which modules they came from, and the location of those usages. Additional keys may be added to the <code>NamedTuple</code>&#39;s in the future in non-breaking releases of ExplicitImports.jl.</p><p><strong>Arguments</strong></p><ul><li><code>mod::Module</code>: the module to (recursively) analyze. Often this is a package.</li><li><code>file=pathof(mod)</code>: this should be a path to the source code that contains the module <code>mod</code>.<ul><li>if <code>mod</code> is the top-level module of a package, <code>pathof</code> will be unable to find the code, and a file must be passed which contains <code>mod</code> (either directly or indirectly through <code>include</code>s)</li><li><code>mod</code> can be a submodule defined within <code>file</code>, but if two modules have the same name (e.g. <code>X.Y.X</code> and <code>X</code>), results may be inaccurate.</li></ul></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>warn_stale=true</code>: whether or not to warn about stale explicit imports.</p></li><li><p><code>strict=true</code>: when <code>strict</code> is set, results for a module will be <code>nothing</code> in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>mod</code> is a package, we can detect the explicit_imports in the package extensions if those extensions are explicitly loaded before calling this function.</p><p>For example, consider <code>PackageA</code> has a weak-dependency on <code>PackageB</code> and <code>PackageC</code> in the module <code>PkgBPkgCExt</code></p><pre><code class="language-julia-repl hljs">julia&gt; using ExplicitImports, PackageA

julia&gt; explicit_imports(PackageA) # Only checks for explicit imports in PackageA and its submodules but not in `PkgBPkgCExt`</code></pre><p>To check for explicit imports in <code>PkgBPkgCExt</code>, you can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; using ExplicitImports, PackageA, PackageB, PackageC

julia&gt; explicit_imports(PackageA) # Now checks for explicit imports in PackageA and its submodules and also in `PkgBPkgCExt`</code></pre></div></div><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> to easily compute and print these results, <a href="#ExplicitImports.explicit_imports_nonrecursive"><code>explicit_imports_nonrecursive</code></a> for a non-recursive version which ignores submodules, and  <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a> for a version that throws errors, for regression testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L57-L96">source</a></section></article><h2 id="Looking-just-for-stale-explicit-exports"><a class="docs-heading-anchor" href="#Looking-just-for-stale-explicit-exports">Looking just for stale explicit exports</a><a id="Looking-just-for-stale-explicit-exports-1"></a><a class="docs-heading-anchor-permalink" href="#Looking-just-for-stale-explicit-exports" title="Permalink"></a></h2><p>While <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> prints stale explicit exports, and <a href="#ExplicitImports.explicit_imports"><code>explicit_imports</code></a> by default provides a warning when stale explicit exports are present, sometimes one wants to only look for stale explicit imports without looking at implicit imports. Here we provide some entrypoints that help for this use-case.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.print_stale_explicit_imports" href="#ExplicitImports.print_stale_explicit_imports"><code>ExplicitImports.print_stale_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_stale_explicit_imports([io::IO=stdout,] mod::Module, file=pathof(mod); strict=true, show_locations=false)</code></pre><p>Runs <a href="#ExplicitImports.stale_explicit_imports"><code>stale_explicit_imports</code></a> and prints the results.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>strict=true</code>: when <code>strict</code> is set, a module will be noted as unanalyzable in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li><li><p><code>show_locations=false</code>: whether or not to print where the explicit imports were made. If the same name was explicitly imported more than once, it will only show one such import.</p></li></ul><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> and <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L262-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.stale_explicit_imports" href="#ExplicitImports.stale_explicit_imports"><code>ExplicitImports.stale_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stale_explicit_imports(mod::Module, file=pathof(mod); strict=true)</code></pre><p>Returns a collection of pairs, where the keys are submodules of <code>mod</code> (including <code>mod</code> itself), and the values are either <code>nothing</code> if <code>strict=true</code> and the module couldn&#39;t analyzed, or else a vector of <code>NamedTuple</code>s with at least the keys <code>name</code> and <code>location</code>, consisting of names that are explicitly imported in that submodule, but which either are not used, or are only used in a qualified fashion, making the explicit import a priori unnecessary.</p><p>More keys may be added to the NamedTuples in the future in non-breaking releases of ExplicitImports.jl.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Note that it is possible for an import from a module (say <code>X</code>) into one module (say <code>A</code>) to be relied on from another unrelated module (say <code>B</code>). For example, if <code>A</code> contains the code <code>using X: x</code>, but either does not use <code>x</code> at all or only uses <code>x</code> in the form <code>X.x</code>, then <code>x</code> will be flagged as a stale explicit import by this function. However, it could be that the code in some unrelated module <code>B</code> uses <code>A.x</code> or <code>using A: x</code>, relying on the fact that <code>x</code> has been imported into <code>A</code>&#39;s namespace.</p><p>This is an unusual situation (generally <code>B</code> should just get <code>x</code> directly from <code>X</code>, rather than indirectly via <code>A</code>), but there are situations in which it arises, so one may need to be careful about naively removing all &quot;stale&quot; explicit imports flagged by this function.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>strict=true</code>: when <code>strict</code> is set, results for a module will be <code>nothing</code> in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</li></ul><p>See <a href="#ExplicitImports.stale_explicit_imports_nonrecursive"><code>stale_explicit_imports_nonrecursive</code></a> for a non-recursive version, and <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a> for a version that throws an error when encountering stale explicit imports.</p><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> which prints this information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L304-L323">source</a></section></article><h2 id="Checks-to-use-in-testing"><a class="docs-heading-anchor" href="#Checks-to-use-in-testing">Checks to use in testing</a><a id="Checks-to-use-in-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Checks-to-use-in-testing" title="Permalink"></a></h2><p>ExplicitImports.jl provides two functions which can be used to regression test that there is no reliance on implicit imports or stale explicit imports:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_no_implicit_imports" href="#ExplicitImports.check_no_implicit_imports"><code>ExplicitImports.check_no_implicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_no_implicit_imports(mod::Module, file=pathof(mod); skip=(mod, Base, Core), ignore::Tuple=(), allow_unanalyzable::Tuple=())</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules is relying on implicit imports, throwing an <code>ImplicitImportsException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This function can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_no_implicit_imports(MyPackage) === nothing</code></pre><p><strong>Allowing some submodules to be unanalyzable</strong></p><p>Pass <code>allow_unanalyzable</code> as a tuple of submodules which are allowed to be unanalyzable. Any other submodules found to be unanalyzable will result in an <code>UnanalyzableModuleException</code> being thrown.</p><p>These unanalyzable submodules can alternatively be included in <code>ignore</code>.</p><p><strong>Allowing some implicit imports</strong></p><p>The <code>skip</code> keyword argument can be passed to allow implicit imports from some modules (and their submodules). By default, <code>skip</code> is set to <code>(Base, Core)</code>. For example:</p><pre><code class="language-julia hljs">@test check_no_implicit_imports(MyPackage; skip=(Base, Core, DataFrames)) === nothing</code></pre><p>would verify there are no implicit imports from modules other than Base, Core, and DataFrames.</p><p>Additionally, the keyword <code>ignore</code> can be passed to represent a tuple of items to ignore. These can be:</p><ul><li>modules. Any submodule of <code>mod</code> matching an element of <code>ignore</code> is skipped. This can be used to allow the usage of implicit imports in some submodule of your package.</li><li>symbols: any implicit import of a name matching an element of <code>ignore</code> is ignored (does not throw)</li><li><code>symbol =&gt; module</code> pairs. Any implicit import of a name matching that symbol from a module matching the module is ignored.</li></ul><p>One can mix and match between these type of ignored elements. For example:</p><pre><code class="language-julia hljs">@test check_no_implicit_imports(MyPackage; ignore=(:DataFrame =&gt; DataFrames, :ByRow, MySubModule)) === nothing</code></pre><p>This would:</p><ol><li>Ignore any implicit import of <code>DataFrame</code> from DataFrames</li><li>Ignore any implicit import of the name <code>ByRow</code> from any module.</li><li>Ignore any implicit imports present in <code>MyPackage</code>&#39;s submodule <code>MySubModule</code></li></ol><p>but verify there are no other implicit imports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/checks.jl#L38-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_no_stale_explicit_imports" href="#ExplicitImports.check_no_stale_explicit_imports"><code>ExplicitImports.check_no_stale_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_no_stale_explicit_imports(mod::Module, file=pathof(mod); ignore::Tuple=(), allow_unanalyzable::Tuple=())</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has stale (unused) explicit imports, throwing an <code>StaleImportsException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_no_stale_explicit_imports(MyPackage) === nothing</code></pre><p><strong>Allowing some submodules to be unanalyzable</strong></p><p>Pass <code>allow_unanalyzable</code> as a tuple of submodules which are allowed to be unanalyzable. Any other submodules found to be unanalyzable will result in an <code>UnanalyzableModuleException</code> being thrown.</p><p><strong>Allowing some stale explicit imports</strong></p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be stale explicit imports. For example,</p><pre><code class="language-julia hljs">@test check_no_stale_explicit_imports(MyPackage; ignore=(:DataFrame,)) === nothing</code></pre><p>would check there were no stale explicit imports besides that of the name <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/checks.jl#L127-L154">source</a></section></article><h2 id="Usage-with-scripts-(such-as-runtests.jl)"><a class="docs-heading-anchor" href="#Usage-with-scripts-(such-as-runtests.jl)">Usage with scripts (such as <code>runtests.jl</code>)</a><a id="Usage-with-scripts-(such-as-runtests.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-with-scripts-(such-as-runtests.jl)" title="Permalink"></a></h2><p>We also provide a helper function to analyze scripts (rather than modules). If you are using a module in your script (e.g. if your script starts with <code>module</code>), then use the ordinary <code>print_explicit_imports</code> function instead. This functionality is somewhat experimental and attempts to filter the relevant names in <code>Main</code> to those used in your script.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.print_explicit_imports_script" href="#ExplicitImports.print_explicit_imports_script"><code>ExplicitImports.print_explicit_imports_script</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_explicit_imports_script([io::IO=stdout,] path; skip=(Base, Core), warn_stale=true)</code></pre><p>Analyzes the script located at <code>path</code> and prints information about reliance on implicit exports as well as any stale explicit imports (if <code>warn_stale=true</code>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"></div></div><p>The script (or at least, all imports in the script) must be run before this function can give reliable results, since it relies on introspecting what names are present in <code>Main</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>warn_stale=true</code>: if set, this function will also print information about stale explicit imports.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L512-L524">source</a></section></article><h2 id="Non-recursive-variants"><a class="docs-heading-anchor" href="#Non-recursive-variants">Non-recursive variants</a><a id="Non-recursive-variants-1"></a><a class="docs-heading-anchor-permalink" href="#Non-recursive-variants" title="Permalink"></a></h2><p>The above functions all recurse through submodules of the provided module, providing information about each. Here, we provide non-recursive variants (which in fact power the recursive ones), in case it is useful, perhaps for building other tooling on top of ExplicitImports.jl.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.explicit_imports_nonrecursive" href="#ExplicitImports.explicit_imports_nonrecursive"><code>ExplicitImports.explicit_imports_nonrecursive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">explicit_imports_nonrecursive(mod::Module, file=pathof(mod); skip=(mod, Base, Core), warn_stale=true, strict=true)</code></pre><p>A non-recursive version of <a href="#ExplicitImports.explicit_imports"><code>explicit_imports</code></a>, meaning it only analyzes the module <code>mod</code> itself, not any of its submodules; see that function for details.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>warn_stale=true</code>: whether or not to warn about stale explicit imports.</p></li><li><p><code>strict=true</code>: when <code>strict=true</code>, results will be <code>nothing</code> in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L192-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.stale_explicit_imports_nonrecursive" href="#ExplicitImports.stale_explicit_imports_nonrecursive"><code>ExplicitImports.stale_explicit_imports_nonrecursive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stale_explicit_imports_nonrecursive(mod::Module, file=pathof(mod); strict=true)</code></pre><p>A non-recursive version of <a href="#ExplicitImports.stale_explicit_imports"><code>stale_explicit_imports</code></a>, meaning it only analyzes the module <code>mod</code> itself, not any of its submodules.</p><p>If <code>mod</code> was unanalyzable and <code>strict=true</code>, returns <code>nothing</code>. Otherwise, returns a collection of <code>NamedTuple</code>&#39;s, with at least the keys <code>name</code> and <code>location</code>, corresponding to the names of stale explicit imports. More keys may be added in the future in non-breaking releases of ExplicitImports.jl.</p><p><strong>Keyword arguments</strong></p><ul><li><code>strict=true</code>: when <code>strict=true</code>, results will be <code>nothing</code> in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</li></ul><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> and <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a>, both of which do recurse through submodules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/ca9a12daac23802312ec0ca5bc28cf5a33738712/src/ExplicitImports.jl#L335-L347">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../internals/">Dev docs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 3 March 2024 14:08">Sunday 3 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
