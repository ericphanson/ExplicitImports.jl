<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · ExplicitImports.jl</title><meta name="title" content="API reference · ExplicitImports.jl"/><meta property="og:title" content="API reference · ExplicitImports.jl"/><meta property="twitter:title" content="API reference · ExplicitImports.jl"/><meta name="description" content="Documentation for ExplicitImports.jl."/><meta property="og:description" content="Documentation for ExplicitImports.jl."/><meta property="twitter:description" content="Documentation for ExplicitImports.jl."/><meta property="og:url" content="https://ericphanson.github.io/ExplicitImports.jl/api/"/><meta property="twitter:url" content="https://ericphanson.github.io/ExplicitImports.jl/api/"/><link rel="canonical" href="https://ericphanson.github.io/ExplicitImports.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExplicitImports.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#Detecting-implicit-imports-which-could-be-made-explicit"><span>Detecting implicit imports which could be made explicit</span></a></li><li><a class="tocitem" href="#Detecting-&quot;improper&quot;-explicit-imports"><span>Detecting &quot;improper&quot; explicit imports</span></a></li><li><a class="tocitem" href="#Detecting-&quot;improper&quot;-access-of-names-from-other-modules"><span>Detecting &quot;improper&quot; access of names from other modules</span></a></li><li><a class="tocitem" href="#Checks-to-use-in-testing"><span>Checks to use in testing</span></a></li><li><a class="tocitem" href="#Usage-with-scripts-(such-as-runtests.jl)"><span>Usage with scripts (such as <code>runtests.jl</code>)</span></a></li><li><a class="tocitem" href="#Non-recursive-variants"><span>Non-recursive variants</span></a></li><li><a class="tocitem" href="#Usage-from-the-command-line"><span>Usage from the command line</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Dev docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ericphanson/ExplicitImports.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ericphanson/ExplicitImports.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The main entrypoint for interactive use is <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a>. ExplicitImports.jl API also includes several other functions to provide programmatic access to the information gathered by the package, as well as utilities to use in regression testing.</p><h2 id="Detecting-implicit-imports-which-could-be-made-explicit"><a class="docs-heading-anchor" href="#Detecting-implicit-imports-which-could-be-made-explicit">Detecting implicit imports which could be made explicit</a><a id="Detecting-implicit-imports-which-could-be-made-explicit-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-implicit-imports-which-could-be-made-explicit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.print_explicit_imports" href="#ExplicitImports.print_explicit_imports"><code>ExplicitImports.print_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_explicit_imports([io::IO=stdout,] mod::Module, file=pathof(mod); skip=(mod, Base, Core),
                       warn_implicit_imports=true,
                       warn_improper_explicit_imports=true,
                       warn_improper_qualified_accesses=true,
                       report_non_public=VERSION &gt;= v&quot;1.11-&quot;,
                        strict=true)</code></pre><p>Runs <a href="#ExplicitImports.explicit_imports"><code>explicit_imports</code></a> and prints the results, along with those of <a href="#ExplicitImports.improper_explicit_imports"><code>improper_explicit_imports</code></a> and <a href="#ExplicitImports.improper_qualified_accesses"><code>improper_qualified_accesses</code></a>.</p><p>Note that the particular printing may change in future non-breaking releases of ExplicitImports.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>warn_improper_explicit_imports=true</code>: if set, this function will also print information about any &quot;improper&quot; imports of names from other modules.</p></li><li><p><code>warn_improper_qualified_accesses=true</code>: if set, this function will also print information about any &quot;improper&quot; qualified accesses to names from other modules.</p></li><li><p><code>strict=true</code>: when <code>strict</code> is set, a module will be noted as unanalyzable in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li><li><p><code>show_locations=false</code>: whether or not to print locations of where the names are being used.</p></li><li><p><code>separate_lines=false</code>: whether or not to print each <code>using</code> statement on a separate line. Automatically occurs when <code>show_locations=true</code>.</p></li><li><p><code>linewidth=80</code>: format into lines of up to this length. Set to 0 to indicate one name should be printed per line.</p></li><li><p><code>report_non_public=VERSION &gt;= v&quot;1.11-&quot;</code>: report if there are accesses or imports of non-public names (that is, names that are not exported nor marked public). By default, only activates on Julia v1.11+.</p></li><li><p><code>allow_internal_accesses=true</code>: if false, reports non-owning or non-public qualified accesses to other modules in the same package</p></li><li><p><code>allow_internal_imports=true</code>: if false, reports non-owning or non-public explicit imports from other modules in the same package</p></li></ul><p>See also <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a>, <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a>, <a href="#ExplicitImports.check_all_qualified_accesses_via_owners"><code>check_all_qualified_accesses_via_owners</code></a>, and <a href="#ExplicitImports.check_all_explicit_imports_via_owners"><code>check_all_explicit_imports_via_owners</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/interactive_usage.jl#L16-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.explicit_imports" href="#ExplicitImports.explicit_imports"><code>ExplicitImports.explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">explicit_imports(mod::Module, file=pathof(mod); skip=(mod, Base, Core), strict=true)</code></pre><p>Returns a nested structure providing information about explicit import statements one could make for each submodule of <code>mod</code>. This information is structured as a collection of pairs, where the keys are the submodules of <code>mod</code> (including <code>mod</code> itself), and the values are <code>NamedTuple</code>s, with at least the keys <code>name</code>, <code>source</code>, <code>exporters</code>, and <code>location</code>, showing which names are being used implicitly, which modules they were defined in, which modules they were exported from, and the location of those usages. Additional keys may be added to the <code>NamedTuple</code>&#39;s in the future in non-breaking releases of ExplicitImports.jl.</p><p><strong>Arguments</strong></p><ul><li><code>mod::Module</code>: the module to (recursively) analyze. Often this is a package.</li><li><code>file=pathof(mod)</code>: this should be a path to the source code that contains the module <code>mod</code>.<ul><li>if <code>mod</code> is the top-level module of a package, <code>pathof</code> will be unable to find the code, and a file must be passed which contains <code>mod</code> (either directly or indirectly through <code>include</code>s)</li><li><code>mod</code> can be a submodule defined within <code>file</code>, but if two modules have the same name (e.g. <code>X.Y.X</code> and <code>X</code>), results may be inaccurate.</li></ul></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>strict=true</code>: when <code>strict</code> is set, results for a module will be <code>nothing</code> in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>mod</code> is a package, we can detect the explicit_imports in the package extensions if those extensions are explicitly loaded before calling this function.</p><p>For example, consider <code>PackageA</code> has a weak-dependency on <code>PackageB</code> and <code>PackageC</code> in the module <code>PkgBPkgCExt</code></p><pre><code class="language-julia-repl hljs">julia&gt; using ExplicitImports, PackageA

julia&gt; explicit_imports(PackageA) # Only checks for explicit imports in PackageA and its submodules but not in `PkgBPkgCExt`</code></pre><p>To check for explicit imports in <code>PkgBPkgCExt</code>, you can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; using ExplicitImports, PackageA, PackageB, PackageC

julia&gt; explicit_imports(PackageA) # Now checks for explicit imports in PackageA and its submodules and also in `PkgBPkgCExt`</code></pre></div></div><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> to easily compute and print these results, <a href="#ExplicitImports.explicit_imports_nonrecursive"><code>explicit_imports_nonrecursive</code></a> for a non-recursive version which ignores submodules, and  <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a> for a version that throws errors, for regression testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/ExplicitImports.jl#L76-L113">source</a></section></article><h2 id="Detecting-&quot;improper&quot;-explicit-imports"><a class="docs-heading-anchor" href="#Detecting-&quot;improper&quot;-explicit-imports">Detecting &quot;improper&quot; explicit imports</a><a id="Detecting-&quot;improper&quot;-explicit-imports-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-&quot;improper&quot;-explicit-imports" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.improper_explicit_imports" href="#ExplicitImports.improper_explicit_imports"><code>ExplicitImports.improper_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">improper_explicit_imports(mod::Module, file=pathof(mod); strict=true, skip=(Base =&gt; Core,
                                                                     Compat =&gt; Base,
                                                                     Compat =&gt; Core),
                          allow_internal_imports=true)</code></pre><p>Attempts do detect various kinds of &quot;improper&quot; explicit imports taking place in <code>mod</code> and any submodules of <code>mod</code>.</p><p>Currently detects two classes of issues:</p><ul><li>names which are explicitly imported but unused (stale)</li><li>names which are not public in <code>mod</code><ul><li>here, public means either exported or declared with the <code>public</code> keyword (requires Julia v1.11+)</li><li>one particularly egregious type of non-public import is when a name is imported from a module which does not even &quot;own&quot; that name. See the returned fields <code>importing_from_owns_name</code> and <code>importing_from_submodule_owns_name</code> for two variations on this.</li></ul></li></ul><p>The keyword argument <code>allow_internal_imports</code> determines whether or not &quot;internal&quot; explicit imports to other modules in the same package (or more generally, sharing the same <code>Base.moduleroot</code>) are reported here. If <code>allow_internal_imports=false</code>, then even such &quot;internal&quot; explicit imports will be returned.</p><p>The keyword argument <code>skip</code> is expected to be an iterator of <code>importing_from =&gt; parent</code> pairs, where names which are imported from <code>importing_from</code> but who have an ancestor which is <code>parent</code> are ignored. By default, imports from Base to names owned by Core are skipped.</p><p>This functionality is still in development, so the exact results may change in future non-breaking releases. Read on for the current outputs, what may change, and what will not change (without a breaking release of ExplicitImports.jl).</p><p>Returns a nested structure providing information about improper explicit imports to names in other modules. This information is structured as a collection of pairs, where the keys are the submodules of <code>mod</code> (including <code>mod</code> itself). Currently, the values are either <code>nothing</code> or a <code>Vector</code> of <code>NamedTuple</code>s with the following keys:</p><ul><li><code>name::Symbol</code>: the name being imported</li><li><code>location::String</code>: the location the import takes place</li><li><code>value::Any</code>: the which <code>name</code> points to in <code>mod</code></li><li><code>importing_from::Module</code>: the module the name is being imported from (e.g. in the example <code>using Foo.X: bar</code>, this would be <code>X</code>)</li><li><code>whichmodule::Module</code>: the <code>Base.which</code> of the object</li><li><code>public_import::Bool</code>: whether or not <code>name</code> is public or exported in <code>importing_from</code>. Checking if a name is marked <code>public</code> requires Julia v1.11+.</li><li><code>importing_from_owns_name::Bool</code>: whether or not <code>importing_from</code> matches <code>whichmodule</code> and therefore is considered to directly &quot;own&quot; the name</li><li><code>importing_from_submodule_owns_name::Bool</code>: whether or not <code>whichmodule</code> is a submodule of <code>importing_from</code></li><li><code>stale::Bool</code>: whether or not the explicitly imported name is used</li><li><code>internal_import::Bool</code>: whether or not the import is &quot;internal&quot;, meaning the module it was imported into and the module it was imported from share the same <code>Base.moduleroot</code>.</li></ul><p>If <code>strict=true</code>, then returns <code>nothing</code> if <code>mod</code> could not be fully analyzed.</p><p>In non-breaking releases of ExplicitImports:</p><ul><li>more columns may be added to these rows</li><li>additional rows may be returned which qualify as some other kind of &quot;improper&quot; access</li></ul><p>However, the result will be a Tables.jl-compatible row-oriented table (for each module), with at least all of the same columns (or the value will be <code>nothing</code> if <code>strict=true</code> and the module could not be fully analyzed).</p><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> to easily compute and print these results, <a href="#ExplicitImports.improper_explicit_imports_nonrecursive"><code>improper_explicit_imports_nonrecursive</code></a> for a non-recursive version which ignores submodules, as well as <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a>, <a href="#ExplicitImports.check_all_explicit_imports_via_owners"><code>check_all_explicit_imports_via_owners</code></a>, and <a href="#ExplicitImports.check_all_explicit_imports_are_public"><code>check_all_explicit_imports_are_public</code></a> for specific regression-testing helpers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/improper_explicit_imports.jl#L202-L246">source</a></section></article><h2 id="Detecting-&quot;improper&quot;-access-of-names-from-other-modules"><a class="docs-heading-anchor" href="#Detecting-&quot;improper&quot;-access-of-names-from-other-modules">Detecting &quot;improper&quot; access of names from other modules</a><a id="Detecting-&quot;improper&quot;-access-of-names-from-other-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-&quot;improper&quot;-access-of-names-from-other-modules" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.improper_qualified_accesses" href="#ExplicitImports.improper_qualified_accesses"><code>ExplicitImports.improper_qualified_accesses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">improper_qualified_accesses(mod::Module, file=pathof(mod); skip=(Base =&gt; Core,
                                                                     Compat =&gt; Base,
                                                                     Compat =&gt; Core),
                            allow_internal_accesses=true)</code></pre><p>Attempts do detect various kinds of &quot;improper&quot; qualified accesses taking place in <code>mod</code> and any submodules of <code>mod</code>.</p><p>Currently, only detects cases in which the name is being accessed from a module <code>mod</code> for which:</p><ul><li><code>name</code> is not exported from <code>mod</code></li><li>or <code>name</code> is not declared public in <code>mod</code> (requires Julia v1.11+)</li><li>or <code>name</code> is &quot;self-qualified&quot;: i.e. in the module <code>Foo</code>, <code>Foo.name</code> is being accessed.</li></ul><p>The keyword argument <code>allow_internal_accesses</code> determines whether or not &quot;internal&quot; qualified accesses to other modules in the same package (or more generally, sharing the same <code>Base.moduleroot</code>) are reported here. If <code>allow_internal_accesses=false</code>, then even such &quot;internal&quot; qualified accesses will be returned. Note self-qualified accesses are reported regardless of the setting of <code>allow_internal_accesses</code>.</p><p>The keyword argument <code>skip</code> is expected to be an iterator of <code>accessing_from =&gt; parent</code> pairs, where names which are accessed from <code>accessing_from</code> but who have an ancestor <code>parent</code> are ignored. By default, accesses from Base to names owned by Core are skipped.</p><p>This functionality is still in development, so the exact results may change in future non-breaking releases. Read on for the current outputs, what may change, and what will not change (without a breaking release of ExplicitImports.jl).</p><p>Returns a nested structure providing information about improper accesses to names in other modules. This information is structured as a collection of pairs, where the keys are the submodules of <code>mod</code> (including <code>mod</code> itself). Currently, the values are a <code>Vector</code> of <code>NamedTuple</code>s with the following keys:</p><ul><li><code>name::Symbol</code>: the name being accessed</li><li><code>location::String</code>: the location the access takes place</li><li><code>value::Any</code>: the which <code>name</code> points to in <code>mod</code></li><li><code>accessing_from::Module</code>: the module the name is being accessed from (e.g. <code>Module.name</code>)</li><li><code>whichmodule::Module</code>: the <code>Base.which</code> of the object</li><li><code>public_access::Bool</code>: whether or not <code>name</code> is public or exported in <code>accessing_from</code>. Checking if a name is marked <code>public</code> requires Julia v1.11+.</li><li><code>accessing_from_owns_name::Bool</code>: whether or not <code>accessing_from</code> matches <code>whichmodule</code> and therefore is considered to directly &quot;own&quot; the name</li><li><code>accessing_from_submodule_owns_name::Bool</code>: whether or not <code>whichmodule</code> is a submodule of <code>accessing_from</code></li><li><code>internal_access::Bool</code>: whether or not the access is &quot;internal&quot;, meaning the module it was accessed in and the module it was accessed from share the same <code>Base.moduleroot</code>.</li><li><code>self_qualified::Bool</code>: whether or not the access is &quot;self-qualified&quot;, meaning the module it was accessed in and the module it is accessed from are the same module.</li></ul><p>In non-breaking releases of ExplicitImports:</p><ul><li>more columns may be added to these rows</li><li>additional rows may be returned which qualify as some other kind of &quot;improper&quot; access</li></ul><p>However, the result will be a Tables.jl-compatible row-oriented table (for each module), with at least all of the same columns.</p><p>See also <a href="#ExplicitImports.print_explicit_imports"><code>print_explicit_imports</code></a> to easily compute and print these results, <a href="#ExplicitImports.improper_qualified_accesses_nonrecursive"><code>improper_qualified_accesses_nonrecursive</code></a> for a non-recursive version which ignores submodules, and the <code>check_</code> functions  <a href="#ExplicitImports.check_all_qualified_accesses_via_owners"><code>check_all_qualified_accesses_via_owners</code></a> and <a href="#ExplicitImports.check_all_explicit_imports_are_public"><code>check_all_explicit_imports_are_public</code></a> for versions that throws errors, for regression testing.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ExplicitImports

julia&gt; example_path = pkgdir(ExplicitImports, &quot;examples&quot;, &quot;qualified.jl&quot;);

julia&gt; print(read(example_path, String))
module MyMod
using LinearAlgebra
# sum is in `Base`, so we shouldn&#39;t access it from LinearAlgebra:
n = LinearAlgebra.sum([1, 2, 3])
end

julia&gt; include(example_path);

julia&gt; row = improper_qualified_accesses(MyMod, example_path)[1][2][1];

julia&gt; (; row.name, row.accessing_from, row.whichmodule)
(name = :sum, accessing_from = LinearAlgebra, whichmodule = Base)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/improper_qualified_accesses.jl#L153-L216">source</a></section></article><h2 id="Checks-to-use-in-testing"><a class="docs-heading-anchor" href="#Checks-to-use-in-testing">Checks to use in testing</a><a id="Checks-to-use-in-testing-1"></a><a class="docs-heading-anchor-permalink" href="#Checks-to-use-in-testing" title="Permalink"></a></h2><p>ExplicitImports.jl provides several functions (all starting with <code>check_</code>) which introspect a module for various kinds of potential issues, and throws errors if these issues are encountered. These &quot;check&quot; functions are designed to be narrowly scoped to detect one specific type of issue, and stable so that they can be used in testing environments (with the aim that non-breaking releases of ExplicitExports.jl will generally not cause new test failures).</p><p>The first such check is <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a> which aims to ensure there are no implicit exports used in the package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_no_implicit_imports" href="#ExplicitImports.check_no_implicit_imports"><code>ExplicitImports.check_no_implicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_no_implicit_imports(mod::Module, file=pathof(mod); skip=(mod, Base, Core), ignore::Tuple=(),
                          allow_unanalyzable::Tuple=())</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules is relying on implicit imports, throwing an <code>ImplicitImportsException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This function can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_no_implicit_imports(MyPackage) === nothing</code></pre><p><strong>Allowing some submodules to be unanalyzable</strong></p><p>Pass <code>allow_unanalyzable</code> as a tuple of submodules which are allowed to be unanalyzable. Any other submodules found to be unanalyzable will result in an <code>UnanalyzableModuleException</code> being thrown.</p><p>These unanalyzable submodules can alternatively be included in <code>ignore</code>.</p><p><strong>Allowing some implicit imports</strong></p><p>The <code>skip</code> keyword argument can be passed to allow implicit imports from some modules (and their submodules). By default, <code>skip</code> is set to <code>(Base, Core)</code>. For example:</p><pre><code class="language-julia hljs">@test check_no_implicit_imports(MyPackage; skip=(Base, Core, DataFrames)) === nothing</code></pre><p>would verify there are no implicit imports from modules other than Base, Core, and DataFrames.</p><p>Additionally, the keyword <code>ignore</code> can be passed to represent a tuple of items to ignore. These can be:</p><ul><li>modules. Any submodule of <code>mod</code> matching an element of <code>ignore</code> is skipped. This can be used to allow the usage of implicit imports in some submodule of your package.</li><li>symbols: any implicit import of a name matching an element of <code>ignore</code> is ignored (does not throw)</li><li><code>symbol =&gt; module</code> pairs. Any implicit import of a name matching that symbol from a module matching the module is ignored.</li></ul><p>One can mix and match between these type of ignored elements. For example:</p><pre><code class="language-julia hljs">@test check_no_implicit_imports(MyPackage; ignore=(:DataFrame =&gt; DataFrames, :ByRow, MySubModule)) === nothing</code></pre><p>This would:</p><ol><li>Ignore any implicit import of <code>DataFrame</code> from DataFrames</li><li>Ignore any implicit import of the name <code>ByRow</code> from any module.</li><li>Ignore any implicit imports present in <code>MyPackage</code>&#39;s submodule <code>MySubModule</code></li></ol><p>but verify there are no other implicit imports.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L173-L222">source</a></section></article><p>Next, we have several checks related to detecting &quot;improper&quot; explicit imports. The function <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a> checks that a module has no &quot;stale&quot; (unused) explicit imports. Next <a href="#ExplicitImports.check_all_explicit_imports_via_owners"><code>check_all_explicit_imports_via_owners</code></a> and <a href="#ExplicitImports.check_all_explicit_imports_are_public"><code>check_all_explicit_imports_are_public</code></a> provide related checks. <a href="#ExplicitImports.check_all_explicit_imports_via_owners"><code>check_all_explicit_imports_via_owners</code></a> is a weaker check which errors for particularly problematic imports of non-public names, namely those for which the module they are being imported from does not &quot;own&quot; the name (since it was not defined there). The typical scenario here is that the name may be public in some other module, but just happens to be present in the namespace of that module (consider <code>using LinearAlgebra: map</code> which imports Base&#39;s <code>map</code> function). Next, <a href="#ExplicitImports.check_all_explicit_imports_are_public"><code>check_all_explicit_imports_are_public</code></a> provides a stricter check that all names being explicitly imported are in fact public in the module they are being imported from, whether or not they are &quot;owned&quot; by that module.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_no_stale_explicit_imports" href="#ExplicitImports.check_no_stale_explicit_imports"><code>ExplicitImports.check_no_stale_explicit_imports</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_no_stale_explicit_imports(mod::Module, file=pathof(mod); ignore::Tuple=(), allow_unanalyzable::Tuple=())</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has stale (unused) explicit imports, throwing an <code>StaleImportsException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_no_stale_explicit_imports(MyPackage) === nothing</code></pre><p><strong>Allowing some submodules to be unanalyzable</strong></p><p>Pass <code>allow_unanalyzable</code> as a tuple of submodules which are allowed to be unanalyzable. Any other submodules found to be unanalyzable will result in an <code>UnanalyzableModuleException</code> being thrown.</p><p><strong>Allowing some stale explicit imports</strong></p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be stale explicit imports. For example,</p><pre><code class="language-julia hljs">@test check_no_stale_explicit_imports(MyPackage; ignore=(:DataFrame,)) === nothing</code></pre><p>would check there were no stale explicit imports besides that of the name <code>DataFrame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L125-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_all_explicit_imports_via_owners" href="#ExplicitImports.check_all_explicit_imports_via_owners"><code>ExplicitImports.check_all_explicit_imports_via_owners</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_all_explicit_imports_via_owners(mod::Module, file=pathof(mod); ignore::Tuple=(),
                                      require_submodule_import=false,
                                      skip::Tuple{Vararg{Pair{Module, Module}, N}} where N=(Base =&gt; Core,
                                                                     Compat =&gt; Base,
                                                                     Compat =&gt; Core)),
                                      allow_internal_imports=true)</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has imports to names via modules other than their owner as determined by <code>Base.which</code> (unless the name is public or exported in that module), throwing an <code>ExplicitImportsFromNonOwnerException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_all_explicit_imports_via_owners(MyPackage) === nothing</code></pre><p><strong>Allowing some explicit imports via non-owner modules</strong></p><p>The <code>skip</code> keyword argument can be passed to allow non-owning imports from some modules (and their submodules). One pases a tuple of <code>importing_from =&gt; parent</code> pairs, allowing cases in which a name is being imported from the module <code>importing_from</code>, but is owned by the module <code>parent</code>. By default, <code>skip</code> is set to <code>(Base =&gt; Core,)</code>, meaning that names which are imported from Base but are owned by Core are not flagged.</p><p>For example:</p><pre><code class="language-julia hljs">@test check_all_explicit_imports_are_public(MyPackage; skip=(Base =&gt; Core, DataFrames =&gt; PrettyTables)) === nothing</code></pre><p>would allow explicitly importing names which are owned by PrettyTables from DataFrames.</p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be accessed from non-owner modules. For example,</p><pre><code class="language-julia hljs">@test check_all_explicit_imports_via_owners(MyPackage; ignore=(:DataFrame,)) === nothing</code></pre><p>would check there were no explicit imports from non-owner modules besides that of the name <code>DataFrame</code>.</p><p><strong><code>require_submodule_import</code></strong></p><p>If <code>require_submodule_import=true</code>, then an error will be thrown if the name is imported from a non-owner module even if it is imported from a parent module of the owner module. For example, in June 2024, <code>JSON.parse</code> is actually defined in the submodule <code>JSON.Parser</code> and is not declared public inside <code>JSON</code>, but the name is present within the module <code>JSON</code>. If <code>require_submodule_import=false</code>, the default, in this scenario the access <code>using JSON: parse</code> will not trigger an error, since the name is being accessed by a parent of the owner. If <code>require_submodule_import=false</code>, then accessing the function as <code>using JSON.Parser: parse</code> will be required to avoid an error.</p><p><strong>non-fully-analyzable modules do not cause exceptions</strong></p><p>Note that if a module is not fully analyzable (e.g. it has dynamic <code>include</code> calls), explicit imports of non-public names which could not be analyzed will be missed. Unlike <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a> and <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a>, this function will <em>not</em> throw an <code>UnanalyzableModuleException</code> in such cases.</p><p>See also: <a href="#ExplicitImports.improper_explicit_imports"><code>improper_explicit_imports</code></a> for programmatic access to such imports and the meaning of the keyword argument <code>allow_internal_imports</code>, and <a href="#ExplicitImports.check_all_explicit_imports_are_public"><code>check_all_explicit_imports_are_public</code></a> for a stricter version of this check. Note that while <code>improper_explicit_imports</code> may increase in scope and report other kinds of improper accesses, <code>check_all_explicit_imports_via_owners</code> will not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L475-L522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_all_explicit_imports_are_public" href="#ExplicitImports.check_all_explicit_imports_are_public"><code>ExplicitImports.check_all_explicit_imports_are_public</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_all_explicit_imports_are_public(mod::Module, file=pathof(mod); ignore::Tuple=(),
                                      skip::Tuple{Vararg{Pair{Module, Module}, N}} where N=(Base =&gt; Core,),
                                      allow_internal_imports=true)</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has imports to names which are non-public (i.e. not exported, nor declared public on Julia 1.11+) throwing an <code>NonPublicExplicitImportsException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_all_explicit_imports_are_public(MyPackage) === nothing</code></pre><p><strong>Allowing some non-public explicit imports</strong></p><p>The <code>skip</code> keyword argument can be passed to allow non-public imports from some modules (and their submodules). One pases a tuple of <code>importing_from =&gt; pub</code> pairs, allowing cases in which a name is being imported from the module <code>importing_from</code>, but is public in the module <code>pub</code>. By default, <code>skip</code> is set to <code>(Base =&gt; Core,)</code>, meaning that names which are imported from Base but are public in Core are not flagged.</p><p>For example:</p><pre><code class="language-julia hljs">@test check_all_explicit_imports_are_public(MyPackage; skip=(Base =&gt; Core, DataFrames =&gt; PrettyTables)) === nothing</code></pre><p>would allow explicitly importing names which are public in PrettyTables from DataFrames.</p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be imported from modules in which they are not public. For example,</p><pre><code class="language-julia hljs">@test check_all_explicit_imports_are_public(MyPackage; ignore=(:DataFrame,)) === nothing</code></pre><p>would check there were no non-public explicit imports besides that of the name <code>DataFrame</code>.</p><p><strong>non-fully-analyzable modules do not cause exceptions</strong></p><p>Note that if a module is not fully analyzable (e.g. it has dynamic <code>include</code> calls), explicit imports of non-public names which could not be analyzed will be missed. Unlike <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a> and <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a>, this function will <em>not</em> throw an <code>UnanalyzableModuleException</code> in such cases.</p><p>See also: <a href="#ExplicitImports.improper_explicit_imports"><code>improper_explicit_imports</code></a> for programmatic access to such imports and the meaning of the keyword argument <code>allow_internal_imports</code>, and [<code>check_all_explicit_imports_via_owners</code>] for a weaker version of this check. Note that while <code>improper_explicit_imports</code> may increase in scope and report other kinds of improper accesses, <code>check_all_explicit_imports_are_public</code> will not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L566-L606">source</a></section></article><p>Lastly, we have two checks related to detecting &quot;improper&quot; qualified accesses to names, which are analogous to checks related to improper explicit imports.  <a href="#ExplicitImports.check_all_qualified_accesses_via_owners"><code>check_all_qualified_accesses_via_owners</code></a> checks that all qualified accesses (e.g. usage of names in the form <code>Foo.bar</code>) are such that the name being accessed is &quot;owned&quot; by the module it is being accessed from (just like <a href="#ExplicitImports.check_all_explicit_imports_via_owners"><code>check_all_explicit_imports_via_owners</code></a>). This would detect, e.g., <code>LinearAlgebra.map</code>. Likewise, <a href="#ExplicitImports.check_all_qualified_accesses_are_public"><code>check_all_qualified_accesses_are_public</code></a> is a stricter check which verifies all qualified accesses to names are via modules in which that name is public. Additionally, <a href="#ExplicitImports.check_no_self_qualified_accesses"><code>check_no_self_qualified_accesses</code></a> checks there are no self-qualified accesses, like accessing <code>Foo.foo</code> from within the module <code>Foo</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_all_qualified_accesses_via_owners" href="#ExplicitImports.check_all_qualified_accesses_via_owners"><code>ExplicitImports.check_all_qualified_accesses_via_owners</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_all_qualified_accesses_via_owners(mod::Module, file=pathof(mod); ignore::Tuple=(),
                                        require_submodule_access=false,
                                        skip::Tuple{Vararg{Pair{Module, Module}, N}} where N=(Base =&gt; Core,
                                                                       Compat =&gt; Base,
                                                                       Compat =&gt; Core),
                                        allow_internal_accesses=true)</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has accesses to names via modules other than their owner as determined by <code>Base.which</code> (unless the name is public or exported in that module), throwing an <code>QualifiedAccessesFromNonOwnerException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_all_qualified_accesses_via_owners(MyPackage) === nothing</code></pre><p><strong>Allowing some qualified accesses via non-owner modules</strong></p><p>The <code>skip</code> keyword argument can be passed to allow non-owning accesses via some modules (and their submodules). One pases a tuple of <code>accessing_from =&gt; parent</code> pairs, allowing cases in which a name is being imported from the module <code>accessing_from</code>, but is owned by the module <code>parent</code>. By default, <code>skip</code> is set to <code>(Base =&gt; Core,)</code>, meaning that names which are accessed from Base but are owned by Core are not flagged.</p><p>For example:</p><pre><code class="language-julia hljs">@test check_all_qualified_accesses_via_owners(MyPackage; skip=(Base =&gt; Core, DataFrames =&gt; PrettyTables)) === nothing</code></pre><p>would allow explicitly accessing names which are owned by PrettyTables from DataFrames.</p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be accessed from non-owner modules. For example,</p><pre><code class="language-julia hljs">@test check_all_qualified_accesses_via_owners(MyPackage; ignore=(:DataFrame,)) === nothing</code></pre><p>would check there were no qualified accesses from non-owner modules besides that of the name <code>DataFrame</code>.</p><p>If <code>require_submodule_access=true</code>, then an error will be thrown if the name is accessed by a non-owner module even if it is accessed by a parent module of the owner module. For example, in June 2024, <code>JSON.parse</code> is actually defined in the submodule <code>JSON.Parser</code> and is not declared public inside <code>JSON</code>, but the name is present within the module <code>JSON</code>. If <code>require_submodule_access=false</code>, the default, in this scenario the access <code>JSON.parse</code> will not trigger an error, since the name is being accessed by a parent of the owner. If <code>require_submodule_access=false</code>, then accessing the function as <code>JSON.Parser.parse</code> will be required to avoid an error.</p><p>See also: <a href="#ExplicitImports.improper_qualified_accesses"><code>improper_qualified_accesses</code></a> for programmatic access and the meaning of the keyword argument <code>allow_internal_accesses</code>, and <a href="#ExplicitImports.check_all_qualified_accesses_are_public"><code>check_all_qualified_accesses_are_public</code></a> for a stricter version of this check. Note that while <code>improper_qualified_accesses</code> may increase in scope and report other kinds of improper accesses, <code>check_all_qualified_accesses_via_owners</code> will not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L263-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_all_qualified_accesses_are_public" href="#ExplicitImports.check_all_qualified_accesses_are_public"><code>ExplicitImports.check_all_qualified_accesses_are_public</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_all_qualified_accesses_are_public(mod::Module, file=pathof(mod); ignore::Tuple=(),
                                        skip::Tuple{Vararg{Pair{Module, Module}, N}} where N=(Base =&gt; Core,),
                                        allow_internal_accesses=true)</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has qualified accesses to names which are non-public (i.e. not exported, nor declared public on Julia 1.11+) throwing an <code>NonPublicQualifiedAccessException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_all_qualified_accesses_are_public(MyPackage) === nothing</code></pre><p><strong>Allowing some non-public qualified accesses</strong></p><p>The <code>skip</code> keyword argument can be passed to allow non-public qualified accesses from some modules (and their submodules). One pases a tuple of <code>accessing_from =&gt; pub</code> pairs, allowing cases in which a name is being accessed from the module <code>accessing_from</code>, but is public in the module <code>pub</code>. By default, <code>skip</code> is set to <code>(Base =&gt; Core,)</code>, meaning that names which are accessed from Base but are public in Core are not flagged.</p><p>For example:</p><pre><code class="language-julia hljs">@test check_all_qualified_accesses_are_public(MyPackage; skip=(Base =&gt; Core, DataFrames =&gt; PrettyTables)) === nothing</code></pre><p>would allow accessing names which are public in PrettyTables from DataFrames.</p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be accessed from modules in which they are not public. For example,</p><pre><code class="language-julia hljs">@test check_all_qualified_accesses_are_public(MyPackage; ignore=(:DataFrame,)) === nothing</code></pre><p>would check there were no non-public qualified accesses besides that of the name <code>DataFrame</code>.</p><p><strong>non-fully-analyzable modules do not cause exceptions</strong></p><p>Note that if a module is not fully analyzable (e.g. it has dynamic <code>include</code> calls), qualified accesess of non-public names which could not be analyzed will be missed. Unlike <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a> and <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a>, this function will <em>not</em> throw an <code>UnanalyzableModuleException</code> in such cases.</p><p>See also: <a href="#ExplicitImports.improper_qualified_accesses"><code>improper_qualified_accesses</code></a> for programmatic access and the meaning of the keyword argument <code>allow_internal_accesses</code>, and [<code>check_all_qualified_accesses_via_owners</code>] for a weaker version of this check. Note that while <code>improper_qualified_accesses</code> may increase in scope and report other kinds of improper accesses, <code>check_all_qualified_accesses_are_public</code> will not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L342-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.check_no_self_qualified_accesses" href="#ExplicitImports.check_no_self_qualified_accesses"><code>ExplicitImports.check_no_self_qualified_accesses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_no_self_qualified_accesses(mod::Module, file=pathof(mod);
                                ignore::Tuple=())</code></pre><p>Checks that neither <code>mod</code> nor any of its submodules has self-qualified accesses, throwing an <code>SelfQualifiedAccessException</code> if so, and returning <code>nothing</code> otherwise.</p><p>This can be used in a package&#39;s tests, e.g.</p><pre><code class="language-julia hljs">@test check_no_self_qualified_accesses(MyPackage) === nothing</code></pre><p><strong>Allowing some self-qualified accesses</strong></p><p>If <code>ignore</code> is supplied, it should be a tuple of <code>Symbol</code>s, representing names that are allowed to be self-qualified. For example,</p><pre><code class="language-julia hljs">@test check_no_self_qualified_accesses(MyPackage; ignore=(:foo,)) === nothing</code></pre><p>would check there were no self-qualified accesses besides that of the name <code>foo</code>.</p><p><strong>non-fully-analyzable modules do not cause exceptions</strong></p><p>Note that if a module is not fully analyzable (e.g. it has dynamic <code>include</code> calls), qualified accesess of non-public names which could not be analyzed will be missed. Unlike <a href="#ExplicitImports.check_no_stale_explicit_imports"><code>check_no_stale_explicit_imports</code></a> and <a href="#ExplicitImports.check_no_implicit_imports"><code>check_no_implicit_imports</code></a>, this function will <em>not</em> throw an <code>UnanalyzableModuleException</code> in such cases.</p><p>See also: <a href="#ExplicitImports.improper_qualified_accesses"><code>improper_qualified_accesses</code></a> for programmatic access to the same information. Note that while <code>improper_qualified_accesses</code> may increase in scope and report other kinds of improper accesses, <code>check_all_qualified_accesses_are_public</code> will not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/checks.jl#L422-L451">source</a></section></article><h2 id="Usage-with-scripts-(such-as-runtests.jl)"><a class="docs-heading-anchor" href="#Usage-with-scripts-(such-as-runtests.jl)">Usage with scripts (such as <code>runtests.jl</code>)</a><a id="Usage-with-scripts-(such-as-runtests.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-with-scripts-(such-as-runtests.jl)" title="Permalink"></a></h2><p>We also provide a helper function to analyze scripts (rather than modules). If you are using a module in your script (e.g. if your script starts with <code>module</code>), then use the ordinary <code>print_explicit_imports</code> function instead. This functionality is somewhat experimental and attempts to filter the relevant names in <code>Main</code> to those used in your script.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.print_explicit_imports_script" href="#ExplicitImports.print_explicit_imports_script"><code>ExplicitImports.print_explicit_imports_script</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_explicit_imports_script([io::IO=stdout,] path; skip=(Base, Core), warn_improper_explicit_imports=true)</code></pre><p>Analyzes the script located at <code>path</code> and prints information about reliance on implicit exports as well as any &quot;improper&quot; explicit imports (if <code>warn_improper_explicit_imports=true</code>).</p><p>Note that the particular printing may change in future non-breaking releases of ExplicitImports.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The script (or at least, all imports in the script) must be run before this function can give reliable results, since it relies on introspecting what names are present in <code>Main</code>.</p></div></div><p><strong>Keyword arguments</strong></p><ul><li><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/interactive_usage.jl#L240-L253">source</a></section></article><h2 id="Non-recursive-variants"><a class="docs-heading-anchor" href="#Non-recursive-variants">Non-recursive variants</a><a id="Non-recursive-variants-1"></a><a class="docs-heading-anchor-permalink" href="#Non-recursive-variants" title="Permalink"></a></h2><p>The above functions all recurse through submodules of the provided module, providing information about each. Here, we provide non-recursive variants (which in fact power the recursive ones), in case it is useful, perhaps for building other tooling on top of ExplicitImports.jl.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.explicit_imports_nonrecursive" href="#ExplicitImports.explicit_imports_nonrecursive"><code>ExplicitImports.explicit_imports_nonrecursive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">explicit_imports_nonrecursive(mod::Module, file=pathof(mod); skip=(mod, Base, Core), strict=true)</code></pre><p>A non-recursive version of <a href="#ExplicitImports.explicit_imports"><code>explicit_imports</code></a>, meaning it only analyzes the module <code>mod</code> itself, not any of its submodules; see that function for details.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>skip=(mod, Base, Core)</code>: any names coming from the listed modules (or any submodules thereof) will be skipped. Since <code>mod</code> is included by default, implicit imports of names exported from its own submodules will not count by default.</p></li><li><p><code>strict=true</code>: when <code>strict=true</code>, results will be <code>nothing</code> in the case that the analysis could not be performed accurately, due to e.g. dynamic <code>include</code> statements. When <code>strict=false</code>, results are returned in all cases, but may be inaccurate.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/ExplicitImports.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.improper_qualified_accesses_nonrecursive" href="#ExplicitImports.improper_qualified_accesses_nonrecursive"><code>ExplicitImports.improper_qualified_accesses_nonrecursive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">improper_qualified_accesses_nonrecursive(mod::Module, file=pathof(mod); skip=(Base =&gt; Core,
                                                                     Compat =&gt; Base,
                                                                     Compat =&gt; Core),
                                         allow_internal_accesses=true)</code></pre><p>A non-recursive version of <a href="#ExplicitImports.improper_qualified_accesses"><code>improper_qualified_accesses</code></a>, meaning it only analyzes the module <code>mod</code> itself, not any of its submodules; see that function for details, including important caveats about stability (outputs may grow in future non-breaking releases of ExplicitImports!).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ExplicitImports

julia&gt; example_path = pkgdir(ExplicitImports, &quot;examples&quot;, &quot;qualified.jl&quot;);

julia&gt; print(read(example_path, String))
module MyMod
using LinearAlgebra
# sum is in `Base`, so we shouldn&#39;t access it from LinearAlgebra:
n = LinearAlgebra.sum([1, 2, 3])
end

julia&gt; include(example_path);

julia&gt; row = improper_qualified_accesses_nonrecursive(MyMod, example_path)[1];

julia&gt; (; row.name, row.accessing_from, row.whichmodule)
(name = :sum, accessing_from = LinearAlgebra, whichmodule = Base)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/improper_qualified_accesses.jl#L88-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ExplicitImports.improper_explicit_imports_nonrecursive" href="#ExplicitImports.improper_explicit_imports_nonrecursive"><code>ExplicitImports.improper_explicit_imports_nonrecursive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">improper_explicit_imports_nonrecursive(mod::Module, file=pathof(mod); strict=true, skip=(Base =&gt; Core,
                                                                     Compat =&gt; Base,
                                                                     Compat =&gt; Core),
                                       allow_internal_imports=true)</code></pre><p>A non-recursive version of <a href="#ExplicitImports.improper_explicit_imports"><code>improper_explicit_imports</code></a>, meaning it only analyzes the module <code>mod</code> itself, not any of its submodules; see that function for details, including important caveats about stability (outputs may grow in future non-breaking releases of ExplicitImports!).</p><p>If <code>strict=true</code>, then returns <code>nothing</code> if <code>mod</code> could not be fully analyzed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ericphanson/ExplicitImports.jl/blob/dc83d67b4f67a83321a6d1b40bc4df25d68353e4/src/improper_explicit_imports.jl#L155-L164">source</a></section></article><h2 id="Usage-from-the-command-line"><a class="docs-heading-anchor" href="#Usage-from-the-command-line">Usage from the command line</a><a id="Usage-from-the-command-line-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-from-the-command-line" title="Permalink"></a></h2><p>On Julia v1.12+, one can use the syntax <code>julia -m ExplicitImports</code> to run ExplicitImports on a particular path (defaulting to the current working directory). See <a href="https://docs.julialang.org/en/v1.12-dev/NEWS/#Command-line-option-changes">here</a> for the <code>-m</code> flag. ExplicitImports.jl must be installed in the project you start Julia with (e.g. in your v1.12 default environment), and the target package to analyze must be installable on the same version of Julia (e.g. no out-of-date Manifest.toml present in the package environment).</p><p>For example, using <a href="https://github.com/JuliaLang/juliaup"><code>juliaup</code></a>&#39;s <code>nightly</code> feature, one can run ExplicitImports on v1.12 as follows.</p><pre><code class="language-man hljs">❯ julia +nightly -m ExplicitImports --help
NAME
       ExplicitImports.main - analyze a package&#39;s namespace

SYNOPSIS
       julia -m ExplicitImports &lt;path&gt;

DESCRIPTION
       `ExplicitImports.main` (typically invoked as `julia -m ExplicitImports`)
       analyzes a package&#39;s imports and qualified accesses, and prints the results.

OPTIONS
       &lt;path&gt;
           Path to the root directory of the package (default: pwd)
       --help
           Show this message</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../internals/">Dev docs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 5 July 2024 23:12">Friday 5 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
